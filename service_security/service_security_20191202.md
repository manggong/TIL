2019.12.02



# IT서비스와 보안



## 1. 웹의 발전

~~~text
client <--------> Server
					(정적문서 <----> 동적문서)
				  => RDB  			=> CGI(색인기능)
															=> WA(Servlet)
View(HTML, CSS, JAVASCRIPT) 			= 단점 사용자 화면을 태그로 보여줌
Ajax, Dom-script											=> 백엔드 언어 생성
=>서버 쪽 문서 통째로가 아닌									(ex.JSP, ASP, PHP)
	필요한 DATA만 호출											 결과 : MVC패턴 생성
=> SPA(React, Vue)											
~~~

- 인터넷은 알파넷에서 유래되었으며, 초기 정적문서에서는 파일 시스템 구조로 쓰임. 후에 자료양이 많아짐에 따라 목차가 커지는 문제가 발생 됨 후에 색인기능이 추가된 동적문서가 생겨나고 동적문서는 사용자 사용화면이 지저분한 문제가 발생하여 이를 보완한 server - side 언어가 생겨남. MVC패턴 생성 후에 서버 쪽 자료를 통째로 제공하는 것이 아닌 사용자의 요구를 반영하여 실시간 교환이 가능한 ajax등장 > SPA(ex.구글 스마트 검색)

- 정적문서
  - 서버에서 수정하지 않는 한 동일한 서비스 제공 <---> 동적문서

## 2. HTTP

- 요청, 응답 구조 => 보완 : Cookie but! 쉽게 노출 됨(=>보완 : Session) 

- Connectionless = Stateless(상태관리, 연결관리(x)) => Sessionless => 요청간 관계 파악 불가

​        =>문제점! 채팅, 실시간 정보교환 어떻게 해?

~~~~
                  
        -----------연결--------------
                   요청 
 Client ---------------------------> Server
        <--------------------------- 
                   응답	
        -----------해제--------------
~~~~



### 3way - handshaking

- Client가 Server에 연결 할 때

~~~ ~~~~

Client  ---------------------------> Server
								   	SYN
        <---------------------------
                 SYN + ACK
        --------------------------->
                    ACK
~~~



### 4way - handshaking

- Client가 Server에 연결을 해제 할 때

~~~~
Client  ---------------------------> Server
								   FIN
        <---------------------------
                FIN + ACK
        <---------------------------
                   FIN
        --------------------------->
                FIN + ACK
                    
~~~~



### Proxy

````
Client ---------------> Proxy ---------------> Server
       <---------------       <---------------
       												 (템퍼링, 인터셉트)
````



- 프록시 : 중계, 대리자

- 프록시의 역활 : 캐싱, 모니터링 => 통제

- 프록시 사용방법

  - 1. 실행

    2. 네트워크 환경설정

       

### 접근 통제의 요소

- 식별 : 누구냐? (ID)

  - TYPE 1 : 지식 (나만 알고 있음) ex. ID
  - TYPE 2 : 소유 (나만 가지고 있음) ex. 공인인증서
  - TYPE 3 : 특징 (생체) ex. 홍체, 지문
  - TYPE이 2개 결합되면 2 factor, 2개 이상 결합되면 Multi factor

- 인증 : 암구호 (P/W)

  - 화면 : Icon 등을 숨겨서 화면에 미 출력함
  - 기능 : 버전을 나누어 기능을 제한 함 (체험판/ 정식판)
  - 데이터 : DATA에 접근권한을 제한 함 ex. KT DATA 

- 인가 : 권한 (접근통제)

  

### Client에서 자료 요청 시 Server의 반응

- default 조회 (ex. index.html)

- default가 없으면 directory listing option 조회

  ​                            => 해당 디렉토리의 파일 목록을 보여줌

  ​								 보안 상 문제가 있지만 초기 웹의 목적은 공유!

### 이스케이핑

- 의미문자 (meta 문자)

  - SQL문 ' => 문자열의 시작과 끝

  - URL문 & => 파라메터의 구분자

     => ID, P/W에 특수문자 입력 시 문제 발생

- 이스케이핑 방법
  - \ 을 사용
  - 특정 규칙 사용 (ex.아스키코드, &nbsp 등)



### 프로그래밍 시 보완 유의법

~~~~
입력 -------------------------------> 처리 ---------------------------------> 출력
=> 1. 안전한 값 => 계획, 의도된대로 처리
	 2. 안전하지 않은 값 => 검증 후 처리
	 										1. 형식 검증 : 영어, 특수문자, 숫자인지 구분하고 사전에 방지 but! 한국에서는 잘 안됨
	 										2. 내용 검증 : 입력받은 내용이 SQL 상 문제가 없는지 확인 함.
	 																 => 근본전인 해결방안(x), 확산 방어 가능
~~~~



## 3. SQL Injection

SQL Injection(삽입)의 취약점을 이용한 인증과정 우회

- 입력값에 쿼리 조작 문자열 포함 여부를 확인하지 않고 쿼리문 생성 및 실행에 사용하는 경우 발생
  - 쿼리의 구조와 의미를 변경해서 실행
  - 권한 밖의 데이터 접근이 가능
  - DBMS 서버의 쉘을 획득하여 원격에서 제어
  - 쿼리를 통해서 제공되는 기능을 우회

### 방어기법

- 정적쿼리 사용 => 항상 동일한 형태의 쿼리가 실행되는 것을 보장 (라이브러리, 프레임워크 사용)

- 동적쿼리를 사용해야되는 경우 입력값을 검증 후 사용

- 에러 메시지에 시스템 경보가 포함되지 않도록 통제

- 어플리케이션 DB 사용자의 권한을 최소화

  => 3, 4 방법은 직접적 방법은 아니고 확산 방어

### SQL Injection 방법

- 입력값의 전달과정이 내부처리 과정에서 변경없이 사용되는지 확인 (ex. ' 등을 붙여본다)
- 정보확인 후 해당 DB언어로 공격 (ex. #을 이용하여 주석처리)

~~~~
[사용자가 화면을 통해서 값을 입력]
아이디 : aaa 
패스워드 : bbb

[요청 파라미터를 통해서 서버로 전달]
../login.do?id=aaa&pw=bbb

[전달받은 값을 이용하여 쿼리와 같은 내부 로직을 실행]
select * from users where id = 'aaa' and pw = 'bbb'
→ 일치하는 데이터가 있으면 → 로그인 성공
→ 일치하는 데이터가 없으면 → 로그인 실패


#1 입력값이 전달과정과 내부처리 과정에서 변경없이 그대로 사용되는지 확인
   ⇒ 내부 로직을 조작하는 문자열을 추가

[사용자가 화면을 통해서 값을 입력]
아이디 : aaa' 
패스워드 : bbb'

[요청 파라미터를 통해서 서버로 전달]
../login.do?id=aaa'&pw=bbb'

[전달받은 값을 이용하여 쿼리와 같은 내부 로직을 실행]
select * from users where id = 'aaa'' and pw = 'bbb''
⇒ 오류 페이지 → MySQL server version for the right syntax to use near 'bbb''' at line 1
→ 정보를 수집 ⇒ 입력한 값이 전달 및 사용 과정에서 변경이 일어나지 않음을 확인

#2 MySQL 서버의 특징을 이용한 공격
[사용자가 화면을 통해서 값을 입력]
아이디 : aaa' # 
패스워드 : bbb' #

[요청 파라미터를 통해서 서버로 전달]
../login.do?id=aaa' #&pw=bbb' #

[전달받은 값을 이용하여 쿼리와 같은 내부 로직을 실행]
select * from users where id = 'aaa' #' and pw = 'bbb' #'
⇒ 식별 정보 만으로 로그인이 가능
#3 회원가입 페이지를 통해서 확인한 admin 계정(ID)으로 로그인을 시도
[사용자가 화면을 통해서 값을 입력]
아이디 : admin' # 
패스워드 : bbb' #

[요청 파라미터를 통해서 서버로 전달]
../login.do?id=admin' #&pw=bbb' #

[전달받은 값을 이용하여 쿼리와 같은 내부 로직을 실행]
select * from users where id = 'admin' #' and pw = 'bbb' #'
⇒ 일치하는 정보가 있으므로 → 로그인 성공

~~~~

